// Code generated by protoc-gen-go. DO NOT EDIT.
// source: stream.proto

package lumas_core_stream

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type SessionStatus_State int32

const (
	SessionStatus_PLAYING  SessionStatus_State = 0
	SessionStatus_PAUSED   SessionStatus_State = 1
	SessionStatus_TEARDOWN SessionStatus_State = 2
)

var SessionStatus_State_name = map[int32]string{
	0: "PLAYING",
	1: "PAUSED",
	2: "TEARDOWN",
}

var SessionStatus_State_value = map[string]int32{
	"PLAYING":  0,
	"PAUSED":   1,
	"TEARDOWN": 2,
}

func (x SessionStatus_State) String() string {
	return proto.EnumName(SessionStatus_State_name, int32(x))
}

func (SessionStatus_State) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bb17ef3f514bfe54, []int{1, 0}
}

type Source_StreamType int32

const (
	Source_MJPEG Source_StreamType = 0
	Source_RTP   Source_StreamType = 1
)

var Source_StreamType_name = map[int32]string{
	0: "MJPEG",
	1: "RTP",
}

var Source_StreamType_value = map[string]int32{
	"MJPEG": 0,
	"RTP":   1,
}

func (x Source_StreamType) String() string {
	return proto.EnumName(Source_StreamType_name, int32(x))
}

func (Source_StreamType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bb17ef3f514bfe54, []int{4, 0}
}

type Session struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Source               *Source  `protobuf:"bytes,2,opt,name=source,proto3" json:"source,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Session) Reset()         { *m = Session{} }
func (m *Session) String() string { return proto.CompactTextString(m) }
func (*Session) ProtoMessage()    {}
func (*Session) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb17ef3f514bfe54, []int{0}
}

func (m *Session) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Session.Unmarshal(m, b)
}
func (m *Session) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Session.Marshal(b, m, deterministic)
}
func (m *Session) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Session.Merge(m, src)
}
func (m *Session) XXX_Size() int {
	return xxx_messageInfo_Session.Size(m)
}
func (m *Session) XXX_DiscardUnknown() {
	xxx_messageInfo_Session.DiscardUnknown(m)
}

var xxx_messageInfo_Session proto.InternalMessageInfo

func (m *Session) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Session) GetSource() *Source {
	if m != nil {
		return m.Source
	}
	return nil
}

type SessionStatus struct {
	State                SessionStatus_State `protobuf:"varint,1,opt,name=state,proto3,enum=lumas_core_stream.SessionStatus_State" json:"state,omitempty"`
	SentFrames           int64               `protobuf:"varint,2,opt,name=sentFrames,proto3" json:"sentFrames,omitempty"`
	DroppedFrames        int64               `protobuf:"varint,3,opt,name=droppedFrames,proto3" json:"droppedFrames,omitempty"`
	Annotations          []*Annotation       `protobuf:"bytes,4,rep,name=annotations,proto3" json:"annotations,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *SessionStatus) Reset()         { *m = SessionStatus{} }
func (m *SessionStatus) String() string { return proto.CompactTextString(m) }
func (*SessionStatus) ProtoMessage()    {}
func (*SessionStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb17ef3f514bfe54, []int{1}
}

func (m *SessionStatus) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SessionStatus.Unmarshal(m, b)
}
func (m *SessionStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SessionStatus.Marshal(b, m, deterministic)
}
func (m *SessionStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionStatus.Merge(m, src)
}
func (m *SessionStatus) XXX_Size() int {
	return xxx_messageInfo_SessionStatus.Size(m)
}
func (m *SessionStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionStatus.DiscardUnknown(m)
}

var xxx_messageInfo_SessionStatus proto.InternalMessageInfo

func (m *SessionStatus) GetState() SessionStatus_State {
	if m != nil {
		return m.State
	}
	return SessionStatus_PLAYING
}

func (m *SessionStatus) GetSentFrames() int64 {
	if m != nil {
		return m.SentFrames
	}
	return 0
}

func (m *SessionStatus) GetDroppedFrames() int64 {
	if m != nil {
		return m.DroppedFrames
	}
	return 0
}

func (m *SessionStatus) GetAnnotations() []*Annotation {
	if m != nil {
		return m.Annotations
	}
	return nil
}

type Annotation struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Annotation) Reset()         { *m = Annotation{} }
func (m *Annotation) String() string { return proto.CompactTextString(m) }
func (*Annotation) ProtoMessage()    {}
func (*Annotation) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb17ef3f514bfe54, []int{2}
}

func (m *Annotation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Annotation.Unmarshal(m, b)
}
func (m *Annotation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Annotation.Marshal(b, m, deterministic)
}
func (m *Annotation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Annotation.Merge(m, src)
}
func (m *Annotation) XXX_Size() int {
	return xxx_messageInfo_Annotation.Size(m)
}
func (m *Annotation) XXX_DiscardUnknown() {
	xxx_messageInfo_Annotation.DiscardUnknown(m)
}

var xxx_messageInfo_Annotation proto.InternalMessageInfo

func (m *Annotation) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type RTPConfig struct {
	RtpAddress           string   `protobuf:"bytes,1,opt,name=rtpAddress,proto3" json:"rtpAddress,omitempty"`
	AudioRTPPort         int32    `protobuf:"varint,2,opt,name=audioRTPPort,proto3" json:"audioRTPPort,omitempty"`
	VideoRTPPort         int32    `protobuf:"varint,3,opt,name=videoRTPPort,proto3" json:"videoRTPPort,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RTPConfig) Reset()         { *m = RTPConfig{} }
func (m *RTPConfig) String() string { return proto.CompactTextString(m) }
func (*RTPConfig) ProtoMessage()    {}
func (*RTPConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb17ef3f514bfe54, []int{3}
}

func (m *RTPConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RTPConfig.Unmarshal(m, b)
}
func (m *RTPConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RTPConfig.Marshal(b, m, deterministic)
}
func (m *RTPConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RTPConfig.Merge(m, src)
}
func (m *RTPConfig) XXX_Size() int {
	return xxx_messageInfo_RTPConfig.Size(m)
}
func (m *RTPConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_RTPConfig.DiscardUnknown(m)
}

var xxx_messageInfo_RTPConfig proto.InternalMessageInfo

func (m *RTPConfig) GetRtpAddress() string {
	if m != nil {
		return m.RtpAddress
	}
	return ""
}

func (m *RTPConfig) GetAudioRTPPort() int32 {
	if m != nil {
		return m.AudioRTPPort
	}
	return 0
}

func (m *RTPConfig) GetVideoRTPPort() int32 {
	if m != nil {
		return m.VideoRTPPort
	}
	return 0
}

type Source struct {
	Id                   string            `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Type                 Source_StreamType `protobuf:"varint,2,opt,name=type,proto3,enum=lumas_core_stream.Source_StreamType" json:"type,omitempty"`
	Timing               *Timing           `protobuf:"bytes,4,opt,name=timing,proto3" json:"timing,omitempty"`
	RtpConfig            *RTPConfig        `protobuf:"bytes,5,opt,name=rtpConfig,proto3" json:"rtpConfig,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Source) Reset()         { *m = Source{} }
func (m *Source) String() string { return proto.CompactTextString(m) }
func (*Source) ProtoMessage()    {}
func (*Source) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb17ef3f514bfe54, []int{4}
}

func (m *Source) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Source.Unmarshal(m, b)
}
func (m *Source) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Source.Marshal(b, m, deterministic)
}
func (m *Source) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Source.Merge(m, src)
}
func (m *Source) XXX_Size() int {
	return xxx_messageInfo_Source.Size(m)
}
func (m *Source) XXX_DiscardUnknown() {
	xxx_messageInfo_Source.DiscardUnknown(m)
}

var xxx_messageInfo_Source proto.InternalMessageInfo

func (m *Source) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Source) GetType() Source_StreamType {
	if m != nil {
		return m.Type
	}
	return Source_MJPEG
}

func (m *Source) GetTiming() *Timing {
	if m != nil {
		return m.Timing
	}
	return nil
}

func (m *Source) GetRtpConfig() *RTPConfig {
	if m != nil {
		return m.RtpConfig
	}
	return nil
}

type StreamSourceInfo struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Sdp                  string   `protobuf:"bytes,2,opt,name=sdp,proto3" json:"sdp,omitempty"`
	HasLiveStream        bool     `protobuf:"varint,3,opt,name=hasLiveStream,proto3" json:"hasLiveStream,omitempty"`
	Timing               *Timing  `protobuf:"bytes,4,opt,name=timing,proto3" json:"timing,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StreamSourceInfo) Reset()         { *m = StreamSourceInfo{} }
func (m *StreamSourceInfo) String() string { return proto.CompactTextString(m) }
func (*StreamSourceInfo) ProtoMessage()    {}
func (*StreamSourceInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb17ef3f514bfe54, []int{5}
}

func (m *StreamSourceInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StreamSourceInfo.Unmarshal(m, b)
}
func (m *StreamSourceInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StreamSourceInfo.Marshal(b, m, deterministic)
}
func (m *StreamSourceInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamSourceInfo.Merge(m, src)
}
func (m *StreamSourceInfo) XXX_Size() int {
	return xxx_messageInfo_StreamSourceInfo.Size(m)
}
func (m *StreamSourceInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamSourceInfo.DiscardUnknown(m)
}

var xxx_messageInfo_StreamSourceInfo proto.InternalMessageInfo

func (m *StreamSourceInfo) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *StreamSourceInfo) GetSdp() string {
	if m != nil {
		return m.Sdp
	}
	return ""
}

func (m *StreamSourceInfo) GetHasLiveStream() bool {
	if m != nil {
		return m.HasLiveStream
	}
	return false
}

func (m *StreamSourceInfo) GetTiming() *Timing {
	if m != nil {
		return m.Timing
	}
	return nil
}

type Timing struct {
	Live                 bool     `protobuf:"varint,1,opt,name=live,proto3" json:"live,omitempty"`
	StartTime            int64    `protobuf:"varint,2,opt,name=startTime,proto3" json:"startTime,omitempty"`
	StopTime             int64    `protobuf:"varint,3,opt,name=stopTime,proto3" json:"stopTime,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Timing) Reset()         { *m = Timing{} }
func (m *Timing) String() string { return proto.CompactTextString(m) }
func (*Timing) ProtoMessage()    {}
func (*Timing) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb17ef3f514bfe54, []int{6}
}

func (m *Timing) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Timing.Unmarshal(m, b)
}
func (m *Timing) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Timing.Marshal(b, m, deterministic)
}
func (m *Timing) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Timing.Merge(m, src)
}
func (m *Timing) XXX_Size() int {
	return xxx_messageInfo_Timing.Size(m)
}
func (m *Timing) XXX_DiscardUnknown() {
	xxx_messageInfo_Timing.DiscardUnknown(m)
}

var xxx_messageInfo_Timing proto.InternalMessageInfo

func (m *Timing) GetLive() bool {
	if m != nil {
		return m.Live
	}
	return false
}

func (m *Timing) GetStartTime() int64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *Timing) GetStopTime() int64 {
	if m != nil {
		return m.StopTime
	}
	return 0
}

type Video struct {
	Format               string   `protobuf:"bytes,1,opt,name=format,proto3" json:"format,omitempty"`
	Codec                string   `protobuf:"bytes,2,opt,name=codec,proto3" json:"codec,omitempty"`
	PixelFormat          string   `protobuf:"bytes,3,opt,name=pixelFormat,proto3" json:"pixelFormat,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Video) Reset()         { *m = Video{} }
func (m *Video) String() string { return proto.CompactTextString(m) }
func (*Video) ProtoMessage()    {}
func (*Video) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb17ef3f514bfe54, []int{7}
}

func (m *Video) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Video.Unmarshal(m, b)
}
func (m *Video) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Video.Marshal(b, m, deterministic)
}
func (m *Video) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Video.Merge(m, src)
}
func (m *Video) XXX_Size() int {
	return xxx_messageInfo_Video.Size(m)
}
func (m *Video) XXX_DiscardUnknown() {
	xxx_messageInfo_Video.DiscardUnknown(m)
}

var xxx_messageInfo_Video proto.InternalMessageInfo

func (m *Video) GetFormat() string {
	if m != nil {
		return m.Format
	}
	return ""
}

func (m *Video) GetCodec() string {
	if m != nil {
		return m.Codec
	}
	return ""
}

func (m *Video) GetPixelFormat() string {
	if m != nil {
		return m.PixelFormat
	}
	return ""
}

type Audio struct {
	Codec                string   `protobuf:"bytes,1,opt,name=codec,proto3" json:"codec,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Audio) Reset()         { *m = Audio{} }
func (m *Audio) String() string { return proto.CompactTextString(m) }
func (*Audio) ProtoMessage()    {}
func (*Audio) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb17ef3f514bfe54, []int{8}
}

func (m *Audio) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Audio.Unmarshal(m, b)
}
func (m *Audio) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Audio.Marshal(b, m, deterministic)
}
func (m *Audio) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Audio.Merge(m, src)
}
func (m *Audio) XXX_Size() int {
	return xxx_messageInfo_Audio.Size(m)
}
func (m *Audio) XXX_DiscardUnknown() {
	xxx_messageInfo_Audio.DiscardUnknown(m)
}

var xxx_messageInfo_Audio proto.InternalMessageInfo

func (m *Audio) GetCodec() string {
	if m != nil {
		return m.Codec
	}
	return ""
}

type Camera struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	HasVideo             bool     `protobuf:"varint,2,opt,name=hasVideo,proto3" json:"hasVideo,omitempty"`
	HasAudio             bool     `protobuf:"varint,3,opt,name=hasAudio,proto3" json:"hasAudio,omitempty"`
	Video                *Video   `protobuf:"bytes,4,opt,name=video,proto3" json:"video,omitempty"`
	Audio                *Audio   `protobuf:"bytes,5,opt,name=audio,proto3" json:"audio,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Camera) Reset()         { *m = Camera{} }
func (m *Camera) String() string { return proto.CompactTextString(m) }
func (*Camera) ProtoMessage()    {}
func (*Camera) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb17ef3f514bfe54, []int{9}
}

func (m *Camera) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Camera.Unmarshal(m, b)
}
func (m *Camera) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Camera.Marshal(b, m, deterministic)
}
func (m *Camera) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Camera.Merge(m, src)
}
func (m *Camera) XXX_Size() int {
	return xxx_messageInfo_Camera.Size(m)
}
func (m *Camera) XXX_DiscardUnknown() {
	xxx_messageInfo_Camera.DiscardUnknown(m)
}

var xxx_messageInfo_Camera proto.InternalMessageInfo

func (m *Camera) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Camera) GetHasVideo() bool {
	if m != nil {
		return m.HasVideo
	}
	return false
}

func (m *Camera) GetHasAudio() bool {
	if m != nil {
		return m.HasAudio
	}
	return false
}

func (m *Camera) GetVideo() *Video {
	if m != nil {
		return m.Video
	}
	return nil
}

func (m *Camera) GetAudio() *Audio {
	if m != nil {
		return m.Audio
	}
	return nil
}

type Result struct {
	Successful           bool     `protobuf:"varint,1,opt,name=successful,proto3" json:"successful,omitempty"`
	ErrorKind            string   `protobuf:"bytes,2,opt,name=errorKind,proto3" json:"errorKind,omitempty"`
	Message              string   `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Result) Reset()         { *m = Result{} }
func (m *Result) String() string { return proto.CompactTextString(m) }
func (*Result) ProtoMessage()    {}
func (*Result) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb17ef3f514bfe54, []int{10}
}

func (m *Result) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Result.Unmarshal(m, b)
}
func (m *Result) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Result.Marshal(b, m, deterministic)
}
func (m *Result) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Result.Merge(m, src)
}
func (m *Result) XXX_Size() int {
	return xxx_messageInfo_Result.Size(m)
}
func (m *Result) XXX_DiscardUnknown() {
	xxx_messageInfo_Result.DiscardUnknown(m)
}

var xxx_messageInfo_Result proto.InternalMessageInfo

func (m *Result) GetSuccessful() bool {
	if m != nil {
		return m.Successful
	}
	return false
}

func (m *Result) GetErrorKind() string {
	if m != nil {
		return m.ErrorKind
	}
	return ""
}

func (m *Result) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func init() {
	proto.RegisterEnum("lumas_core_stream.SessionStatus_State", SessionStatus_State_name, SessionStatus_State_value)
	proto.RegisterEnum("lumas_core_stream.Source_StreamType", Source_StreamType_name, Source_StreamType_value)
	proto.RegisterType((*Session)(nil), "lumas_core_stream.Session")
	proto.RegisterType((*SessionStatus)(nil), "lumas_core_stream.SessionStatus")
	proto.RegisterType((*Annotation)(nil), "lumas_core_stream.Annotation")
	proto.RegisterType((*RTPConfig)(nil), "lumas_core_stream.RTPConfig")
	proto.RegisterType((*Source)(nil), "lumas_core_stream.Source")
	proto.RegisterType((*StreamSourceInfo)(nil), "lumas_core_stream.StreamSourceInfo")
	proto.RegisterType((*Timing)(nil), "lumas_core_stream.Timing")
	proto.RegisterType((*Video)(nil), "lumas_core_stream.Video")
	proto.RegisterType((*Audio)(nil), "lumas_core_stream.Audio")
	proto.RegisterType((*Camera)(nil), "lumas_core_stream.Camera")
	proto.RegisterType((*Result)(nil), "lumas_core_stream.Result")
}

func init() { proto.RegisterFile("stream.proto", fileDescriptor_bb17ef3f514bfe54) }

var fileDescriptor_bb17ef3f514bfe54 = []byte{
	// 753 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x55, 0x5d, 0x6f, 0xda, 0x48,
	0x14, 0xc5, 0x18, 0x1b, 0x73, 0x49, 0x22, 0x76, 0xb4, 0x5a, 0xb1, 0x28, 0x59, 0xa1, 0xd9, 0x68,
	0x95, 0x27, 0xa4, 0x65, 0x5f, 0x56, 0xab, 0x95, 0x52, 0x94, 0x8f, 0x36, 0x2d, 0x4d, 0xd1, 0x40,
	0x13, 0xf5, 0x29, 0x9d, 0xd8, 0x43, 0x62, 0x09, 0x7b, 0xac, 0x99, 0x71, 0xda, 0xbc, 0xf7, 0xb5,
	0xff, 0xa5, 0xff, 0xa9, 0xcf, 0xfd, 0x0f, 0x95, 0x67, 0xa6, 0xe0, 0x04, 0x48, 0x25, 0x9e, 0xf0,
	0x3d, 0x73, 0xee, 0xe1, 0x7e, 0x1c, 0x7b, 0x60, 0x4b, 0x2a, 0xc1, 0x68, 0xd2, 0xcb, 0x04, 0x57,
	0x1c, 0xfd, 0x32, 0xcb, 0x13, 0x2a, 0xaf, 0x42, 0x2e, 0xd8, 0x95, 0x39, 0xc0, 0x43, 0xa8, 0x8f,
	0x99, 0x94, 0x31, 0x4f, 0xd1, 0x0e, 0x54, 0xe3, 0xa8, 0xed, 0x74, 0x9d, 0x83, 0x06, 0xa9, 0xc6,
	0x11, 0xfa, 0x1b, 0x7c, 0xc9, 0x73, 0x11, 0xb2, 0x76, 0xb5, 0xeb, 0x1c, 0x34, 0xfb, 0xbf, 0xf7,
	0x96, 0xd2, 0x7b, 0x63, 0x4d, 0x20, 0x96, 0x88, 0x3f, 0x55, 0x61, 0xdb, 0xca, 0x8d, 0x15, 0x55,
	0xb9, 0x44, 0xff, 0x83, 0x27, 0x15, 0x55, 0x4c, 0xeb, 0xee, 0xf4, 0xff, 0x5a, 0xa5, 0x51, 0x4e,
	0xe8, 0x15, 0x3f, 0x8c, 0x98, 0x24, 0xf4, 0x07, 0x80, 0x64, 0xa9, 0x3a, 0x15, 0x34, 0x61, 0x52,
	0x97, 0xe1, 0x92, 0x12, 0x82, 0xf6, 0x61, 0x3b, 0x12, 0x3c, 0xcb, 0x58, 0x64, 0x29, 0xae, 0xa6,
	0x3c, 0x04, 0xd1, 0x21, 0x34, 0x69, 0x9a, 0x72, 0x45, 0x55, 0xcc, 0x53, 0xd9, 0xae, 0x75, 0xdd,
	0x83, 0x66, 0x7f, 0x6f, 0x45, 0x25, 0x83, 0x39, 0x8b, 0x94, 0x33, 0x70, 0x0f, 0x3c, 0x5d, 0x16,
	0x6a, 0x42, 0x7d, 0x34, 0x1c, 0xbc, 0x3b, 0x3b, 0x7f, 0xde, 0xaa, 0x20, 0x00, 0x7f, 0x34, 0x78,
	0x3b, 0x3e, 0x39, 0x6e, 0x39, 0x68, 0x0b, 0x82, 0xc9, 0xc9, 0x80, 0x1c, 0xbf, 0xb9, 0x3c, 0x6f,
	0x55, 0xf1, 0x2e, 0xc0, 0x42, 0xea, 0xf1, 0x5c, 0xb1, 0x84, 0x06, 0x99, 0x8c, 0x8e, 0x78, 0x3a,
	0x8d, 0x6f, 0x8a, 0x0e, 0x85, 0xca, 0x06, 0x51, 0x24, 0x98, 0x94, 0x96, 0x54, 0x42, 0x10, 0x86,
	0x2d, 0x9a, 0x47, 0x31, 0x27, 0x93, 0xd1, 0x88, 0x0b, 0xa5, 0x67, 0xe0, 0x91, 0x07, 0x58, 0xc1,
	0xb9, 0x8b, 0x23, 0x36, 0xe7, 0xb8, 0x86, 0x53, 0xc6, 0xf0, 0x57, 0x07, 0x7c, 0xb3, 0xac, 0xa5,
	0x3d, 0xff, 0x0b, 0x35, 0x75, 0x9f, 0x99, 0x2d, 0xef, 0xf4, 0xf7, 0xd7, 0x6e, 0xb9, 0x37, 0xd6,
	0xd1, 0xe4, 0x3e, 0x63, 0x44, 0x67, 0x14, 0x0e, 0x51, 0x71, 0x12, 0xa7, 0x37, 0xed, 0xda, 0x5a,
	0x87, 0x4c, 0x34, 0x81, 0x58, 0x22, 0xfa, 0x0f, 0x1a, 0x42, 0x65, 0xa6, 0xf9, 0xb6, 0xa7, 0xb3,
	0x76, 0x57, 0x64, 0xcd, 0x07, 0x44, 0x16, 0x74, 0xdc, 0x05, 0x58, 0x94, 0x80, 0x1a, 0xe0, 0xbd,
	0x7e, 0x39, 0x3a, 0x29, 0x36, 0x51, 0x07, 0x97, 0x4c, 0x46, 0x2d, 0x07, 0x7f, 0x76, 0xa0, 0x65,
	0x28, 0xa6, 0xe4, 0xb3, 0x74, 0xca, 0x97, 0xfa, 0x6d, 0x81, 0x2b, 0xa3, 0x4c, 0xb7, 0xdb, 0x20,
	0xc5, 0x63, 0x61, 0xa3, 0x5b, 0x2a, 0x87, 0xf1, 0x1d, 0x33, 0xc9, 0x7a, 0x82, 0x01, 0x79, 0x08,
	0x6e, 0xd0, 0x2d, 0xbe, 0x00, 0xdf, 0x20, 0x08, 0x41, 0x6d, 0x16, 0xdf, 0x99, 0xd7, 0x20, 0x20,
	0xfa, 0x19, 0xed, 0x42, 0x43, 0x2a, 0x2a, 0xd4, 0x24, 0x4e, 0x98, 0x35, 0xf7, 0x02, 0x40, 0x1d,
	0x08, 0xa4, 0xe2, 0x99, 0x3e, 0x34, 0xb6, 0x9e, 0xc7, 0xf8, 0x12, 0xbc, 0x8b, 0x62, 0xbb, 0xe8,
	0x37, 0xf0, 0xa7, 0x5c, 0x24, 0x54, 0xd9, 0xfe, 0x6c, 0x84, 0x7e, 0x05, 0x2f, 0xe4, 0x11, 0x0b,
	0x6d, 0x97, 0x26, 0x40, 0x5d, 0x68, 0x66, 0xf1, 0x47, 0x36, 0x3b, 0x35, 0x29, 0xae, 0x3e, 0x2b,
	0x43, 0x78, 0x0f, 0xbc, 0x41, 0x61, 0xad, 0x85, 0x80, 0x53, 0x12, 0xc0, 0x5f, 0x1c, 0xf0, 0x8f,
	0x68, 0xc2, 0x04, 0x5d, 0x9a, 0x6a, 0x07, 0x82, 0x5b, 0x2a, 0x75, 0x55, 0xfa, 0x4f, 0x03, 0x32,
	0x8f, 0xed, 0x99, 0x16, 0xb6, 0xa3, 0x9d, 0xc7, 0xa8, 0x07, 0x9e, 0x36, 0xaa, 0x1d, 0x6a, 0x7b,
	0xc5, 0x50, 0xb5, 0x08, 0x31, 0xb4, 0x82, 0xaf, 0xcd, 0x6f, 0xcd, 0xb3, 0x8a, 0xaf, 0x85, 0x89,
	0xa1, 0xe1, 0xf7, 0xe0, 0x13, 0x26, 0xf3, 0x99, 0xd2, 0x1f, 0x93, 0x3c, 0x0c, 0x99, 0x94, 0xd3,
	0x7c, 0x66, 0x17, 0x51, 0x42, 0x8a, 0x75, 0x30, 0x21, 0xb8, 0x78, 0x15, 0xa7, 0x91, 0x9d, 0xdb,
	0x02, 0x40, 0x6d, 0xa8, 0x27, 0x4c, 0x4a, 0x7a, 0xc3, 0xec, 0xdc, 0x7e, 0x84, 0xfd, 0x6f, 0x2e,
	0xf8, 0xd6, 0x22, 0xcf, 0xc0, 0x93, 0x4c, 0xe5, 0x19, 0x5a, 0xff, 0xad, 0xec, 0x74, 0xd6, 0x7f,
	0x02, 0x71, 0x05, 0x1d, 0x42, 0x2d, 0x9b, 0xd1, 0x7b, 0xf4, 0x04, 0xab, 0xb3, 0x4a, 0xdc, 0xf4,
	0x88, 0x2b, 0x45, 0x09, 0x19, 0xcd, 0x25, 0xdb, 0x5c, 0x61, 0x08, 0x41, 0xc4, 0x64, 0x28, 0xe2,
	0x6b, 0xf6, 0x54, 0x1f, 0x7f, 0xae, 0x3a, 0x7a, 0xf4, 0xee, 0xe1, 0x0a, 0x3a, 0x82, 0x40, 0x31,
	0x2a, 0x22, 0xfe, 0x21, 0xdd, 0xbc, 0xa4, 0x17, 0xe0, 0x4b, 0x73, 0x9f, 0x3c, 0x25, 0xd1, 0xfd,
	0xd9, 0xe5, 0x82, 0x2b, 0x68, 0x00, 0xbe, 0x60, 0x21, 0x17, 0xd1, 0xc6, 0x2b, 0xba, 0xf6, 0xf5,
	0x65, 0xfa, 0xcf, 0xf7, 0x00, 0x00, 0x00, 0xff, 0xff, 0xd5, 0x00, 0x0b, 0x67, 0x5c, 0x07, 0x00,
	0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// StreamClient is the client API for Stream service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type StreamClient interface {
	Setup(ctx context.Context, in *Source, opts ...grpc.CallOption) (*Session, error)
	Play(ctx context.Context, in *Session, opts ...grpc.CallOption) (*Result, error)
	Pause(ctx context.Context, in *Session, opts ...grpc.CallOption) (*Result, error)
	Describe(ctx context.Context, in *Source, opts ...grpc.CallOption) (*StreamSourceInfo, error)
	Teardown(ctx context.Context, in *Session, opts ...grpc.CallOption) (*Result, error)
	Status(ctx context.Context, in *Session, opts ...grpc.CallOption) (*SessionStatus, error)
	Record(ctx context.Context, in *Source, opts ...grpc.CallOption) (*Session, error)
}

type streamClient struct {
	cc *grpc.ClientConn
}

func NewStreamClient(cc *grpc.ClientConn) StreamClient {
	return &streamClient{cc}
}

func (c *streamClient) Setup(ctx context.Context, in *Source, opts ...grpc.CallOption) (*Session, error) {
	out := new(Session)
	err := c.cc.Invoke(ctx, "/lumas_core_stream.Stream/setup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamClient) Play(ctx context.Context, in *Session, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/lumas_core_stream.Stream/play", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamClient) Pause(ctx context.Context, in *Session, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/lumas_core_stream.Stream/pause", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamClient) Describe(ctx context.Context, in *Source, opts ...grpc.CallOption) (*StreamSourceInfo, error) {
	out := new(StreamSourceInfo)
	err := c.cc.Invoke(ctx, "/lumas_core_stream.Stream/describe", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamClient) Teardown(ctx context.Context, in *Session, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/lumas_core_stream.Stream/teardown", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamClient) Status(ctx context.Context, in *Session, opts ...grpc.CallOption) (*SessionStatus, error) {
	out := new(SessionStatus)
	err := c.cc.Invoke(ctx, "/lumas_core_stream.Stream/status", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamClient) Record(ctx context.Context, in *Source, opts ...grpc.CallOption) (*Session, error) {
	out := new(Session)
	err := c.cc.Invoke(ctx, "/lumas_core_stream.Stream/record", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StreamServer is the server API for Stream service.
type StreamServer interface {
	Setup(context.Context, *Source) (*Session, error)
	Play(context.Context, *Session) (*Result, error)
	Pause(context.Context, *Session) (*Result, error)
	Describe(context.Context, *Source) (*StreamSourceInfo, error)
	Teardown(context.Context, *Session) (*Result, error)
	Status(context.Context, *Session) (*SessionStatus, error)
	Record(context.Context, *Source) (*Session, error)
}

// UnimplementedStreamServer can be embedded to have forward compatible implementations.
type UnimplementedStreamServer struct {
}

func (*UnimplementedStreamServer) Setup(ctx context.Context, req *Source) (*Session, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Setup not implemented")
}
func (*UnimplementedStreamServer) Play(ctx context.Context, req *Session) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Play not implemented")
}
func (*UnimplementedStreamServer) Pause(ctx context.Context, req *Session) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Pause not implemented")
}
func (*UnimplementedStreamServer) Describe(ctx context.Context, req *Source) (*StreamSourceInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Describe not implemented")
}
func (*UnimplementedStreamServer) Teardown(ctx context.Context, req *Session) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Teardown not implemented")
}
func (*UnimplementedStreamServer) Status(ctx context.Context, req *Session) (*SessionStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Status not implemented")
}
func (*UnimplementedStreamServer) Record(ctx context.Context, req *Source) (*Session, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Record not implemented")
}

func RegisterStreamServer(s *grpc.Server, srv StreamServer) {
	s.RegisterService(&_Stream_serviceDesc, srv)
}

func _Stream_Setup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Source)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamServer).Setup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lumas_core_stream.Stream/Setup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamServer).Setup(ctx, req.(*Source))
	}
	return interceptor(ctx, in, info, handler)
}

func _Stream_Play_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Session)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamServer).Play(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lumas_core_stream.Stream/Play",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamServer).Play(ctx, req.(*Session))
	}
	return interceptor(ctx, in, info, handler)
}

func _Stream_Pause_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Session)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamServer).Pause(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lumas_core_stream.Stream/Pause",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamServer).Pause(ctx, req.(*Session))
	}
	return interceptor(ctx, in, info, handler)
}

func _Stream_Describe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Source)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamServer).Describe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lumas_core_stream.Stream/Describe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamServer).Describe(ctx, req.(*Source))
	}
	return interceptor(ctx, in, info, handler)
}

func _Stream_Teardown_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Session)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamServer).Teardown(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lumas_core_stream.Stream/Teardown",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamServer).Teardown(ctx, req.(*Session))
	}
	return interceptor(ctx, in, info, handler)
}

func _Stream_Status_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Session)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamServer).Status(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lumas_core_stream.Stream/Status",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamServer).Status(ctx, req.(*Session))
	}
	return interceptor(ctx, in, info, handler)
}

func _Stream_Record_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Source)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamServer).Record(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lumas_core_stream.Stream/Record",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamServer).Record(ctx, req.(*Source))
	}
	return interceptor(ctx, in, info, handler)
}

var _Stream_serviceDesc = grpc.ServiceDesc{
	ServiceName: "lumas_core_stream.Stream",
	HandlerType: (*StreamServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "setup",
			Handler:    _Stream_Setup_Handler,
		},
		{
			MethodName: "play",
			Handler:    _Stream_Play_Handler,
		},
		{
			MethodName: "pause",
			Handler:    _Stream_Pause_Handler,
		},
		{
			MethodName: "describe",
			Handler:    _Stream_Describe_Handler,
		},
		{
			MethodName: "teardown",
			Handler:    _Stream_Teardown_Handler,
		},
		{
			MethodName: "status",
			Handler:    _Stream_Status_Handler,
		},
		{
			MethodName: "record",
			Handler:    _Stream_Record_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "stream.proto",
}
